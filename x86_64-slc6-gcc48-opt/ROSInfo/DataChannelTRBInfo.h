#ifndef DATACHANNELTRBINFO_H
#define DATACHANNELTRBINFO_H

#include <ROSInfo/SingleFragmentDataChannelInfo.h>
#include <string>
#include <ostream>


// <<BeginUserCode>>

// <<EndUserCode>>

namespace ROS
{
/**
 * Statistics from a Trb DataChannel
 * 
 * @author  generated by the IS tool
 * @version 11/05/15
 */

class DataChannelTRBInfo : public SingleFragmentDataChannelInfo {
public:

    /**
     * Min. number of polling cycles before DREADY
     */
    unsigned int                  min_wait;

    /**
     * Max. number of polling cycles before DREADY
     */
    unsigned int                  max_wait;


    static const ISType & type() {
	static const ISType type_ = DataChannelTRBInfo( ).ISInfo::type();
	return type_;
    }

    virtual std::ostream & print( std::ostream & out ) const {
	SingleFragmentDataChannelInfo::print( out );
	out << std::endl;
	out << "min_wait: " << min_wait << "\t// Min. number of polling cycles before DREADY" << std::endl;
	out << "max_wait: " << max_wait << "\t// Max. number of polling cycles before DREADY";
	return out;
    }

    DataChannelTRBInfo( )
      : SingleFragmentDataChannelInfo( "DataChannelTRBInfo" )
    {
	initialize();
    }

    ~DataChannelTRBInfo(){

// <<BeginUserCode>>

// <<EndUserCode>>
    }

protected:
    DataChannelTRBInfo( const std::string & type )
      : SingleFragmentDataChannelInfo( type )
    {
	initialize();
    }

    void publishGuts( ISostream & out ){
	SingleFragmentDataChannelInfo::publishGuts( out );
	out << min_wait << max_wait;
    }

    void refreshGuts( ISistream & in ){
	SingleFragmentDataChannelInfo::refreshGuts( in );
	in >> min_wait >> max_wait;
    }

private:
    void initialize()
    {

// <<BeginUserCode>>

// <<EndUserCode>>
    }


// <<BeginUserCode>>

// <<EndUserCode>>
};

// <<BeginUserCode>>

// <<EndUserCode>>
inline std::ostream & operator<<( std::ostream & out, const DataChannelTRBInfo & info ) {
    info.print( out );
    return out;
}

}

#endif // DATACHANNELTRBINFO_H
