#ifndef DATACHANNELSTYXINFO_H
#define DATACHANNELSTYXINFO_H

#include <ROSInfo/SingleFragmentDataChannelInfo.h>
#include <string>
#include <ostream>


// <<BeginUserCode>>

// <<EndUserCode>>

namespace ROS
{
/**
 * Statistics from a Styx DataChannel
 * 
 * @author  generated by the IS tool
 * @version 27/04/15
 */

class DataChannelSTYXInfo : public SingleFragmentDataChannelInfo {
public:

    /**
     * Min. number of polling cycles before DREADY
     */
    unsigned int                  min_wait;

    /**
     * Max. number of polling cycles before DREADY
     */
    unsigned int                  max_wait;


    static const ISType & type() {
	static const ISType type_ = DataChannelSTYXInfo( ).ISInfo::type();
	return type_;
    }

    virtual std::ostream & print( std::ostream & out ) const {
	SingleFragmentDataChannelInfo::print( out );
	out << std::endl;
	out << "min_wait: " << min_wait << "\t// Min. number of polling cycles before DREADY" << std::endl;
	out << "max_wait: " << max_wait << "\t// Max. number of polling cycles before DREADY";
	return out;
    }

    DataChannelSTYXInfo( )
      : SingleFragmentDataChannelInfo( "DataChannelSTYXInfo" )
    {
	initialize();
    }

    ~DataChannelSTYXInfo(){

// <<BeginUserCode>>

// <<EndUserCode>>
    }

protected:
    DataChannelSTYXInfo( const std::string & type )
      : SingleFragmentDataChannelInfo( type )
    {
	initialize();
    }

    void publishGuts( ISostream & out ){
	SingleFragmentDataChannelInfo::publishGuts( out );
	out << min_wait << max_wait;
    }

    void refreshGuts( ISistream & in ){
	SingleFragmentDataChannelInfo::refreshGuts( in );
	in >> min_wait >> max_wait;
    }

private:
    void initialize()
    {

// <<BeginUserCode>>

// <<EndUserCode>>
    }


// <<BeginUserCode>>

// <<EndUserCode>>
};

// <<BeginUserCode>>

// <<EndUserCode>>
inline std::ostream & operator<<( std::ostream & out, const DataChannelSTYXInfo & info ) {
    info.print( out );
    return out;
}

}

#endif // DATACHANNELSTYXINFO_H
